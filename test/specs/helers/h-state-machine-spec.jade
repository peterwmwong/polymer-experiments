link( rel='import', href='/src/helpers/h-state-machine.html' )

polymer-element( name='h-state-machine-spec' )
  :coffeescript
    Polymer 'h-state-machine-spec', ready: ->

      describe '# h-state-machine', ->
        beforeEach ->
          @StateMachine = document.createElement 'h-state-machine'

        afterEach ->
          window.destroyElement @StateMachine

        describe '## METHODS', ->
          describe '@create( statesConfig:object )', ->
            it '... creates a StateMachine with the behavior described by `statesConfig`.'

            describe 'param `statesConfig`', ->
              it '... key-value hash that enumerates all states and describesthe behavior of each state'
              it  """
                  Lets look at an example of a `statesConfig` for game state
                  machine:
                    start_screen: {}

                    login:
                      canExit: ->
                        # Prevent exiting when user is NOT logged in
                        user?

                    game_easy_level:
                      canEnter: ->
                        # Prevent entering when user is NOT logged in
                        user?

                    game_medium_level:
                      canEnter: ->
                        # Prevent entering when...
                        #   a) user is NOT logged in
                        #   b) easy level hasn't completed
                        user? and levels.easy.completed

                  In this example, there are 4 states ('start_screen', 'login',
                  'game_easy_level', and 'game_medium_level'). Each state is
                  unique in transition behavior (conditions for entering and
                  leaving the state).
                  """


            describe 'Given a valid `stateConfig`', ->
              beforeEach ->
                @stateMachine = @StateMachine.create
                  s1:{}
                  s2:{}
                  s3:{}

              it 'are set to the first specified state in `statesConfig`', ->
                expect(@stateMachine.defaultState.id).toBe 's1'
                expect(@stateMachine.currentState.id).toBe 's1'


          describe '@goto( stateid:string, data?:object ):boolean', ->
            it '... attempts a state transition to specified state (`stateid`) with data (`data`).'
            it 'Returns `true` if transition was successful, otherwise `false`.'

            describe 'For a successful transition, where `stateid` references a valid state', ->
              beforeEach ->
                @stateMachine = @StateMachine.create
                  s1:{}
                  s2:{}
                @stateData = {}
                @returnValue = @stateMachine.goto 's2', @stateData

              it 'returns `true`', ->
                expect(@returnValue).toBe true

              it 'sets @currentState to the new state (@id and @data)', ->
                expect(@stateMachine.currentState.id).toBe 's2'
                expect(@stateMachine.currentState.data).toBe @stateData


        describe '## PROPERTIES', ->
          describe '@currentState', ->
              it '... is the current state of the StateMachine'
              it 'This property is updated after any successful state transition.'
              it 'see ## Methods > @goto( stateId:string, data:object )'

          describe '@defaultState', ->
            it 'see "@create( states:object ) Default State"', ->
